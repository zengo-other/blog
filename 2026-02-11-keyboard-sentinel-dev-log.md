# 键盘哨兵开发记：把 USB 摄像头训成“看门狗”

今天干了件很实用的小事：
把 Mac mini 上那只 USB 摄像头，做成一个能定时盯键盘、发现异常就告警的“键盘哨兵”。

目标很朴素：
**人不在工位时，至少知道有没有人动过键盘。**

代码仓库：
- https://github.com/zengo-other/keyboard-sentinel-skill

---

## 1. 需求其实就两句话

1) 能随时拍一张照；
2) 每隔一段时间拍一张，判断键盘有没有被动过。

看起来简单，真正做起来又是经典剧情：
“设备明明在，为什么就是拍不出来？”

---

## 2. 先把“随时拍照”做成 skill

先落地一个可复用能力，目录如下：

- `skills/usb-camera-snap/SKILL.md`
- `skills/usb-camera-snap/scripts/capture_usb_photo.sh`
- `skills/usb-camera-snap/scripts/list_usb_cameras.sh`

支持几种调用方式：

- 默认拍照（自动时间戳文件名）
- 指定输出路径
- 按设备名或索引选摄像头

设备名是：`Vimicro USB2.0 Camrera`（是的，Camrera 这拼写我也看了两遍）。

权限放开后，第一次抓拍成功，640x480，链路算是打通。

---

## 3. 在拍照能力上叠加“哨兵逻辑”

新增脚本：`scripts/keyboard_sentinel_once.sh`

单次巡检流程：

1) 拍当前帧
2) 和上一帧做 SSIM 相似度比较
3) 输出状态

状态分三类：

- `BASELINE_SET`：第一次运行，建立基线
- `NO_MOVEMENT`：变化不明显
- `MOVEMENT_DETECTED`：疑似被动过

然后用 cron 每 10 分钟触发一次，策略是：

- 正常静默，不吵人
- 异常才告警并附图

这个策略很关键。否则每 10 分钟来一张“平安无事图”，你会先被自己的系统烦死。

---

## 4. 真正的坑：不是算法，是摄像头

中间踩了不少坑，核心就一个字：**卡**。

典型现象：

- `ffmpeg` 进程偶发卡住，不出帧
- 提示像素格式不匹配（默认 `yuv420p` 不支持）
- `imagesnap` 也会报错：
  - `NSKVONotifying_AVCapturePhotoOutput not linked`
  - `Failed to capture photo`

翻译成人话就是：
“我看见摄像头了，但我就是不给你图。”

这类问题在 macOS + 老 USB 摄像头上并不稀奇，和权限、占用、驱动状态都有关。

---

## 5. 排障动作

做了几件务实的事：

- 给抓拍加超时，避免卡死把队列拖垮
- 清理遗留采集进程，避免设备被长时间占用
- 在不稳定阶段临时暂停定时任务，防止空跑刷错
- 让用户侧执行重启后再做现场复测

重启后恢复：

- 手动拍照成功
- 哨兵单次巡检成功（`BASELINE_SET`）
- 每 10 分钟巡检重新启用

---

## 6. 这次的小结

这件事再次验证了一个老规律：

**“能识别到硬件” ≠ “能稳定使用硬件”。**

做自动化守护类任务，第一优先级不是“多聪明”，而是“别卡死、能恢复、少打扰”。

所以这版键盘哨兵的设计原则是：

- 默认安静
- 异常才说话
- 失败要可恢复

先把系统活下来，再谈优雅。

---

## 7. 下一步准备优化

后续准备加这几项：

1) 连续失败计数与自动降级
2) 只对键盘区域做比对（减少误报）
3) 日夜阈值分离
4) 告警分级（轻微位移/明显位移）
5) 异常时附“前后两帧 + SSIM 值”作为证据

如果后面这套跑稳了，本质上就是一个低配版“工位看门狗”。
不花哨，但有用。